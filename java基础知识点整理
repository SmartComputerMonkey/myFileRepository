
JVM

JVM内存结构     
堆、栈、方法区、直接内存、堆和栈区别   了解并指导每部分的工作

Java内存模型
内存可见性、重排序、顺序一致性、volatile、锁、final   了解知悉并深入了解volatile

垃圾回收  
内存分配策略、垃圾收集器（G1）、GC算法、GC参数、对象存活的判定   了解

JVM参数及调优   不清楚

Java对象模型    不清楚不清晰
oop-klass、对象头

HotSpot  不知道
即时编译器、编译优化

类加载机制  了解一部分
classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）

虚拟机性能监控与故障处理工具   不知道
jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler

编译与反编译 不知道
javac 、javap 、jad 、CRF

Java基础知识
阅读源代码  
String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader & URLClassLoader、
ArrayList & LinkedList、 HashMap & LinkedHashMap & TreeMap & CouncurrentHashMap、HashSet & LinkedHashSet & TreeSet

Java中各种变量类型  没看过

熟悉Java String的使用，熟悉String的各种函数   看过
JDK 6和JDK 7中substring的原理及区别、 不知道

replaceFirst、replaceAll、replace区别：
					replaceFirst和replaceAll用到了正则表达式
					replace没有用到正则表达式
					用一个简单的例子就可以看出效果
					String str = "my.test.txt";
					System.out.println(str.replaceFirst(".", "#"));
					System.out.println(str.replaceAll(".", "#"));
					System.out.println(str.replace(".", "#"));
					
					=================================================
					输出结果：
						#y.test.txt
						###########
						my#test#txt
					解释：
						“.”是正则表达式的元字符，匹配除换行符以外的任意字符，所以replaceAll、replaceFirst才出现了这样的结果。
						replace没有用到正则表达式，但会把所有“.”替换掉，很多人可能会误解replace是替换单个，而replaceAll是替换全部，其实这是错的（我以前也是这么想的- -）。replace只是没有用到正则表达式，但会替换所有匹配的字符串
					补充：String的split也是用到了正则表达式，使用的时候注意点


String对“+”的重载
	String str0 = "a";
	String str1 = str0 + "b";
	
	其中“+”反编译出来之后是这样的一个过程
	String str0 = "a";
	StringBuilder sb = new StringBuilder();
	sb.append(str0).append("b");
	String str1 = sb.toString();
	中间多出来了一个StringBuilder对象，这是一个临时对象。
	
	

String.valueOf和Integer.toString的区别
通过读String类的源码可以看到：
	public static String valueOf(int i) {
    	return Integer.toString(i);
	}
	String.valueOf(int i) 其实调用了Integer.toString(int i)方法
通过看Integer类的toString方法源码可以看到：
	public static String toString(int i) {
	    if (i == Integer.MIN_VALUE)
	        return "-2147483648";
	    int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);
	    char[] buf = new char[size];
	    getChars(i, size, buf);
	    return new String(buf, true);
	}
	除了当参数i=-2^31时，值返回"-2147483648"外，当i=其他值时，都返回一个新的Stirng对象（new String(buf,true)）

补充注意：
	java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常
	String.valueOf 这是一个静态方法，直接通过String调用，可以说是完美，只是平时不习惯这样写而已，这样的实现避免了前面两个的不足和缺点。
	源码如下：
		public static String valueOf(Object obj){
    		return (obj==null) ? "null" : obj.toString()
		};
	我们应当注意到，当object为null 时，String.valueOf（object）的值是字符串”null”，而不是null！！！在使用过程中切记要注意。

字符串的不可变性  
	通过查看String源码可知：
		/** The value is used for character storage. */
    	private final char value[];
    	String类是依赖一个私有字符常量表实现的；
    	例如：
    		String c1=new String("abc");
        	String c2=new String("abc");
        	String c3=c1;
        	System.out.println("c1==c2:"+  (c1==c2));
        	System.out.println("c1.equals(c2):"+c1.equals(c2));
        	System.out.println("c3==c1:"+(c3==c1));
        	System.out.println("c1.equals(c3):"+c1.equals(c3));
        	c1="han";
        	System.out.println(c1+"   "+c3);
        	System.out.println(""+(c3==c1));
        	
        	第一个输出语句c1==c2很好理解，因为c1和c2都是用new 创建的对象的引用，虽然对象的值相同，但两个对象在不同的内存空间，也就是说c1和c2是对两个不同的对象的引用，所以结果为false。
        	第二个输出语句c1.equals(c2)是调用了String类的equals方法，该方法用于比较两个字符串对象的值是否相等，所以结果为true。
        	对于c3==c1为true是因为将c1赋值给了c3 也就是将c1对象的引用赋值给了c3；
        	对于System.out.println(c1+"   "+c3)，这个输出语句有人会问既然c1和c3引用的是同一个对象，为什么改变c1的值c3的值并不会改变呢？
			
			这就涉及到了Java中String对象的不可变性，什么叫不可变性呢，简单的说就是一旦一个String对象被创建并被赋值（初始化）这个对象的值就不会变化。
			一旦一个String对象在内存中创建，它将是不可改变的，所有的String类中方法并不是改变String对象自己，而是重新创建一个新的String对象。
			也就是说c1=han，并不是改变了原有对象的值，而是创建了一个新的字符串对象，这个对象的值是han，并把这个对象的引用赋值给了c1。
        	所以c1==c3 为false
        	
        	正因为String对象的不可变性，如果需要对字符串进行大量的修改、添加字符、删除字符等操作尽量不要使用String对象，因为这样会频繁的创建新的对象导致程序的执行效率下降
			这时我们可以使用字符串生成器StringBuilder

String、StringBuffer、StringBuilder区别
	源码层面分析：
		 /** The value is used for character storage. */
    		private final char value[];
    	String类是依赖一个私有字符常量表实现的
    	String为字符串常量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的
    	 /**
    	 * The value is used for character storage.
    	 */
    	char[] value;
    	StringBuffer与StringBuilder都是继承AbstractStringBuilder，然而AbstractStringBuilder类是依赖一个字符变量表实现的
    	StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多
    	
    	在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的
    	如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。
    	所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。
    	
自动拆装箱:自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。
		因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱.
java为什么要引入自动装箱和拆箱的功能？
	主要是用于java集合中，List<Inteter> list=new ArrayList<Integer>();
	list集合如果要放整数的话，只能放对象，不能放基本类型，因此需要将整数自动装箱成对象,基本数据类型，
	如int,float,double,boolean,char,byte,不具备对象的特征，不能调用方法。
例子：
	装箱：将基本类型转换成包装类对象
	int i=10;
	Integer x=new Integer(i);手动装箱
	Integer y=10;自动装箱
	Integer的缓存机制  不知道
	
	拆箱：将包装类对象转换成基本类型的值
	Integer j=new Integer(8);
	int m=j.intValue();//手动拆箱
	int n=j;//自动拆箱
注意点(弊端):
	容易生成无用对象,因为自动装箱会隐式地创建对象，像前面提到的那样，如果在一个循环体中，会创建无用的中间对象，这样会增加GC压力，拉低程序的性能。
	所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作.

Integer的缓存机制
	Java 编译器把原始类型自动转换为封装类的过程称为自动装箱（autoboxing），这相当于调用 valueOf 方法
	 JDK 源码中对应实现的部分在哪里了。我们来看看 valueOf 的源码。下面是 JDK 1.8.0 build 25 中的代码
	 	public static Integer valueOf(int i) {
       		if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
           		return IntegerCache.cache[i + (-IntegerCache.low)];
       		
       		return new Integer(i);
   		}
   	在创建新的 Integer 对象之前会先在 IntegerCache.cache 中查找。有一个专门的 Java 类来负责 Integer 的缓存
   	这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。
   	最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。
   	缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。
   	这个缓存会在 Integer 类第一次被使用的时候被初始化出来。
   	以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。
   	
   	实际上在 Java 5 中引入这个特性的时候，范围是固定的 -128 至 +127。
   	后来在 Java 6 中，最大值映射到 java.lang.Integer.IntegerCache.high，可以使用 JVM 的启动参数设置最大值。
   	这使我们可以根据应用程序的实际情况灵活地调整来提高性能。是什么原因选择这个 -128 到 127 这个范围呢？因为这个范围的整数值是使用最广泛的。 
   	在程序中第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存
   	
   	这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。

	有 ByteCache 用于缓存 Byte 对象
	有 ShortCache 用于缓存 Short 对象
	有 LongCache 用于缓存 Long 对象
	有 CharacterCache 用于缓存 Character 对象
	Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。

熟悉Java中各种关键字
	transient、instanceof、volatile、synchronized、final、static、const 原理及用法。

	transient原理及用法：
        定义： transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。
        作用： Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。
	instanceof原理及用法：
	    用法表达式：
	        result = object instanceof class
               result：布尔类型。
               object：必选项。任意对象表达式。
               class：必选项。任意已定义的对象类。
        原理：
            检测object对象是不是class类型的实例的原理是：class类型是否在object类型的原型链上，如果在result为true，如果不在为false;
	synchronized原理及用法：
	    用法：1、修饰普通方法 2、修饰静态方法 3、修饰代码块
	    作用：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题
	final原理及用法：
            基本用法：
                1、用来修饰类
                        当用final修饰一个类时，表明这个类不能被继承。
                        也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。
                        final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
                2、方法
                     使用final方法的原因有两个，第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用
                     如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。
                     注：类的private方法会隐式地被指定为final方法。
                3、变量（包括成员变量和局部变量）
                    对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；
                    如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
	static原理及用法：
	    用法：
	        是一个修饰符，用于修饰成员（成员变量，成员函数），
            当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用外，
            还可以直接被类名调：类名.静态成员
        存在：方法区，共享区，数据区（非堆内存、栈内存的另一个存储区），Static 块仅在该类被加载时执行一次。
        特点：
            1，随着类的加载而加载，也就是说静态会随着类的消失而消失，说明他的生命周期最长
            2，优先于对象的存在。（静态先存在，对象后存在。）
            3，被所有对象所共享
            4，可以直接被类名调用
            由于静态static不依赖于任何对象就可以进行访问，因此对于静态来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。
            并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。

            内部类中不能存在static修饰的成员，因为static随着类加载产生，内部类依附于宿主类，系统加载：宿主类-->静态-->内部类，而内部类的静态是随着内部类加载产生，与加载类就加载static矛盾，所以内部类中不能存在static修饰
	实例变量和类变量的区别：
	        1，存放位置。
            　　类变量随着类的加载而存在于方法区中。
            　　实例变量随着对象的建立而存在于堆内存中。
            2，生命周期：
            　　类变量生命周期最长，随着类的消失而消失。
            　　实例变量生命周期随着对象的消失而消失。
    注意：
        1，静态方法只能访问静态成员，非静态方法既可以访问静态也可以访问非静态。（Java虚拟机（JVM）加载类时，就会执行该static，静态优先于其他产生对象产生）。
        2，静态方法中不可定义this，super等关键字：
        　　　　（this:this代表当前对象，static于类加载的时候存在优先于实例对象的产生，static调用非静态时并未产生对象，所以this不代表任何对象为null,未进行初始化操作。）
        3，主函数是静态方法。
集合类
常用集合类的使用
ArrayList和LinkedList和Vector的区别: 
	Vector&ArrayList简介及特点
		1、Vector是内部是以动态数组的形式来存储数据的。
		2、Vector具有数组所具有的特性、通过索引支持随机访问、所以通过随机访问Vector中的元素效率非常高、但是执行插入、删除时效率比较地下、具体原因后面有分析。
		3、Vector实现了AbstractList抽象类、List接口、所以其更具有了AbstractList和List的功能、前面我们知道AbstractList内部已经实现了获取Iterator和ListIterator的方法、所以Vector只需关心对数组操作的方法的实现、
		4、Vector实现了RandomAccess接口、此接口只有声明、没有方法体、表示Vector支持随机访问。
		5、Vector实现了Cloneable接口、此接口只有声明、没有方法体、表示Vector支持克隆。
		6、Vector实现了Serializable接口、此接口只有声明、没有方法体、表示Vector支持序列化、即可以将Vector以流的形式通过ObjectOutputStream来写入到流中。
		7、Vector由于使用了synchronized方法-线程安全，所以性能上比ArrayList要差,所以Vector是线程安全的。
	LinkedList的特点：
		是一个双链表，在add和remove时比ArrayList性能好，但get和set时就特别慢了。
		双向链表，链表的一种。每个数据结点中都有两个指针，分别指向直接前驱和直接后继。因此，我们可以方便的访问他的前驱结点和后继结点。
		特点： 
		 1、 LinkedList以链表的形式存储数据、对增删元素有很高的效率、查询效率较低、尤其是随机访问、效率不忍直视、
       	 2、 LinkedList继承AbstractSequentialdList（其继承与AbstractList、所以要求其子类要实现通过索引操作元素）、使得LinkedList支持使用索引的“增删改查”操作、
         3、LinkedList直接实现了List接口、使其可以内部存储元素有序并且为每个元素提供索引值、
         4、LinkedList直接实现了Deque接口、Deque接口继承了Queue、使其可以作为双向链表这种数据结构来使用、操作元素、
         5、LinkedList直接实现了Cloneable接口、使其可以复制其中的全部元素
         6、在使用ObjectOutputStream/ObjectInputStream流时、会先讲LinkedList的capacity读取/写入到流中、然后将元素一一读取/写入。

SynchronizedList和Vector的区别   不知道

HashMap、HashTable、ConcurrentHashMap区别  了解并掌握hashmap

Java 8中stream相关用法  见过

apache集合处理工具类的使用   不知道

不同版本的JDK中HashMap的实现的区别以及原因   清楚jdk1.7和jdk1.8的区别和原因
1.8中应用了红黑树的数据结构   在链表节点超过8个的时候自动转换为红黑树结构  当红黑树的节点减少到6个时  自动转换为链表结构

枚举
枚举的用法、枚举与单例、Enum类 已整理

Java IO&Java NIO，并学会使用    

bio、nio和aio的区别、三种IO的用法与原理、netty

Java反射与javassist    不清楚
反射与工厂模式、 java.lang.reflect.*

Java序列化    没接触
什么是序列化与反序列化、为什么序列化
序列化底层原理
序列化与单例模式
protobuf
为什么说序列化并不安全

注解  没接触
元注解、自定义注解、Java中常用注解使用、注解与反射的结合

JMS 没接触
什么是Java消息服务、JMS消息传送模型

JMX  没见过
java.lang.management.*、 javax.management.*

泛型   表面了解
泛型与继承
类型擦除
泛型中K T V E  
object等的含义、泛型各种用法

单元测试  没玩儿过
junit、mock、mockito、内存数据库（h2）

正则表达式  知道  但不会用
java.lang.util.regex.*

常用的Java工具库  用过其中一个
commons.lang, commons.*... guava-libraries netty

guava-libraries 源码包的简单说明：
　　com.google.common.annotations：普通注解类型。
　　com.google.common.base：基本工具类库和接口。
　　com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。
　　com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。
　　com.google.common.eventbus：发布订阅风格的事件总线。
　　com.google.common.hash： 哈希工具包。
　　com.google.common.io：I/O工具包。
　　com.google.common.math：原始算术类型和超大数的运算工具包。
　　com.google.common.net：网络工具包。
　　com.google.common.primitives：八种原始类型和无符号类型的静态工具包。
　　com.google.common.reflect：反射工具包。
　　com.google.common.util.concurrent：多线程工具包。
类库使用手册：
　　一.  基本工具类：让使用Java语言更令人愉悦。
    　　1. 使用和避免 null：null 有语言歧义， 会产生令人费解的错误， 反正他总是让人不爽。很多 Guava 的工具类在遇到 null 时会直接拒绝或出错，而不是默默地接受他们。
    　　2. 前提条件：更容易的对你的方法进行前提条件的测试。
    　　3. 常见的对象方法： 简化了Object常用方法的实现， 如 hashCode() 和 toString()。
    　　4. 排序： Guava 强大的 "fluent Comparator"比较器， 提供多关键字排序。
    　　5. Throwable类： 简化了异常检查和错误传播。
　　二.  集合类：集合类库是 Guava 对 JDK 集合类的扩展， 这是 Guava 项目最完善和为人所知的部分。
    　　1. Immutable collections（不变的集合）： 防御性编程， 不可修改的集合，并且提高了效率。
    　　2. New collection types(新集合类型)：JDK collections 没有的一些集合类型，主要有：multisets，multimaps，tables， bidirectional maps等等
    　　3. Powerful collection utilities（强大的集合工具类）： java.util.Collections 中未包含的常用操作工具类
    　　4. Extension utilities（扩展工具类）: 给 Collection 对象添加一个装饰器? 实现迭代器? 我们可以更容易使用这些方法。
　　三.  缓存: 本地缓存，可以很方便的操作缓存对象，并且支持各种缓存失效行为模式。
　　四.  Functional idioms（函数式）: 简洁, Guava实现了Java的函数式编程，可以显著简化代码。
　　五. Concurrency（并发）：强大,简单的抽象,让我们更容易实现简单正确的并发性代码。
    　　1. ListenableFuture（可监听的Future）: Futures,用于异步完成的回调。
    　　2. Service: 控制事件的启动和关闭，为你管理复杂的状态逻辑。

　　六. Strings: 一个非常非常有用的字符串工具类: 提供 splitting，joining， padding 等操作。
　　七. Primitives: 扩展 JDK 中未提供的对原生类型（如int、char等）的操作， 包括某些类型的无符号的变量。
　　八. Ranges: Guava 一个强大的 API，提供 Comparable 类型的范围处理， 包括连续和离散的情况。
　　九. I/O: 简化 I/O 操作, 特别是对 I/O 流和文件的操作, for Java 5 and 6.
　　十. Hashing: 提供比 Object.hashCode() 更复杂的 hash 方法, 提供 Bloom filters.
　　十一. EventBus: 基于发布-订阅模式的组件通信，但是不需要明确地注册在委托对象中。
　　十二. Math: 优化的 math 工具类，经过完整测试。

　　十三. Reflection: Guava 的 Java 反射机制工具类。
什么是API&SPI  不知道

异常  了解  但不会用
异常类型、正确处理异常、自定义异常

时间处理  没用过
时区、时令、Java中时间API

编码方式  了解但不会用
解决乱码问题、常用编码方式

语法糖 不知道
Java中语法糖原理、解语法糖

Java并发编程  表面了解
什么是线程，与进程的区别：
    一个程序最少需要一个进程，而一个进程最少需要一个线程。关系是线程C>进程C>程序的大致组成结构。
    所以线程是程序执行流的最小单位，而进程是系统进行资源分配和调度的一个独立单位。

阅读源代码，并学会使用   没读过
Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors

线程池  没用过
自己设计线程池、submit() 和 execute()

线程安全  不清楚
死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系

锁 了解一部分
CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁

死锁  了解
happens-before、编译器指令重排和CPU指令重排

volatile
synchronized
定义：
    Java语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码

synchronized是如何实现的 已总结

synchronized和lock之间关系
本质区别：
    synchronized是基于jvm底层实现的数据同步，lock是基于Java编写，主要通过硬件依赖CPU指令实现数据同步
    类别	               synchronized	                                                                            Lock
    存在层次	           Java的关键字，在jvm层面上	                                                            是一个类
    锁的释放	           1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁	        在finally中必须释放锁，不然容易造成线程死锁
    锁的获取	           假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待	                            分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待
    锁状态	               无法判断	                                                                                可以判断
    锁类型	               可重入 不可中断 非公平	                                                                可重入 可判断 可公平（两者皆可）
    性能	               少量同步	                                                                                大量同步
两种锁的实现方式：
    synchronized是悲观锁，它胆子很小，它很怕有人和它抢吃的，所以它每次吃东西前都把自己关起来
    lock是乐观锁机制，它无所谓，别人抢了它吃的，它重新去拿吃的就好啦，所以它很乐观
尽可能去使用synchronized而不要去使用LOCK
了解Thread的几个重要方法：
    a、start()方法，调用该方法开始执行该线程；
    b、stop()方法，调用该方法强制结束该线程执行；
    c、join方法，调用该方法等待该线程结束。
    d、sleep()方法，调用该方法该线程进入等待。
    e、run()方法，调用该方法直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法
    其实wait()与notify()方法是Object的方法，不是Thread的方法！！同时，wait()与notify()会配合使用，分别表示线程挂起和线程恢复
    wait()与sleep()的区别，简单来说wait()会释放对象锁而sleep()不会释放对象锁
notify 和 notifyAll：
    被wait的线程，想要继续运行的话，它必须满足2个条件：
    由其他线程notify或notifyAll了，并且当前线程被通知到了
    经过和其他线程进行锁竞争，成功获取到锁了
    2个条件，缺一不可。
    其实在实现层面，notify和notifyAll都达到相同的效果，都只会有一个线程继续运行。
    但notifyAll免去了，线程运行完了通知其他线程的必要，因为已经通知过了。
    什么时候用notify，什么时候使用notifyAll，这就得看实际的情况了

Lock接口中的方法解释：
    lock()：获取锁，如果锁被暂用则一直等待
    unlock():释放锁
    tryLock(): 注意返回类型是boolean，如果获取锁的时候锁被占用就返回false，否则返回true
    tryLock(long time, TimeUnit unit)：比起tryLock()就是给了一个时间期限，保证等待参数时间
    lockInterruptibly()：用该锁的获得方式，如果线程在获取锁的阶段进入了等待，那么可以中断此线程，先去做别的事

不使用synchronized如何实现一个线程安全的单例

    public class Singleton {
        private static final AtomicReference<Singleton> INSTANCE = new AtomicReference<Singleton>();

        private Singleton() {}

        public static Singleton getInstance() {
            for (;;) {
                Singleton singleton = INSTANCE.get();
                if (null != singleton) {
                    return singleton;
                }

                singleton = new Singleton();
                if (INSTANCE.compareAndSet(null, singleton)) {
                    return singleton;
                }
            }
        }



ThreadLocal

写一个死锁的程序 会写

写代码来解决生产者消费者问题
优点：
    它简化的开发，你可以独立地或并发的编写消费者和生产者，它仅仅只需知道共享对象是谁
    生产者不需要知道谁是消费者或者有多少消费者，对消费者来说也是一样
    生产者和消费者可以以不同的速度执行
    分离的消费者和生产者在功能上能写出更简洁、可读、易维护的代码

守护线程  不知道
守护线程和非守护线程的区别以及用法  不知道