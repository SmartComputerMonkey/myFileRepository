
JVM

JVM内存结构     
堆、栈、方法区、直接内存、堆和栈区别   了解并指导每部分的工作

Java内存模型
内存可见性、重排序、顺序一致性、volatile、锁、final   了解知悉并深入了解volatile

垃圾回收  
内存分配策略、垃圾收集器（G1）、GC算法、GC参数、对象存活的判定   了解

JVM参数及调优   不清楚

Java对象模型    不清楚不清晰
oop-klass、对象头

HotSpot  不知道
即时编译器、编译优化

类加载机制  了解一部分
classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）

虚拟机性能监控与故障处理工具   不知道
jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler

编译与反编译 不知道
javac 、javap 、jad 、CRF

Java基础知识
阅读源代码  
String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader & URLClassLoader、
ArrayList & LinkedList、 HashMap & LinkedHashMap & TreeMap & CouncurrentHashMap、HashSet & LinkedHashSet & TreeSet

Java中各种变量类型  没看过

熟悉Java String的使用，熟悉String的各种函数   看过
JDK 6和JDK 7中substring的原理及区别、 不知道

replaceFirst、replaceAll、replace区别：
					replaceFirst和replaceAll用到了正则表达式
					replace没有用到正则表达式
					用一个简单的例子就可以看出效果
					String str = "my.test.txt";
					System.out.println(str.replaceFirst(".", "#"));
					System.out.println(str.replaceAll(".", "#"));
					System.out.println(str.replace(".", "#"));
					
					=================================================
					输出结果：
						#y.test.txt
						###########
						my#test#txt
					解释：
						“.”是正则表达式的元字符，匹配除换行符以外的任意字符，所以replaceAll、replaceFirst才出现了这样的结果。
						replace没有用到正则表达式，但会把所有“.”替换掉，很多人可能会误解replace是替换单个，而replaceAll是替换全部，其实这是错的（我以前也是这么想的- -）。replace只是没有用到正则表达式，但会替换所有匹配的字符串
					补充：String的split也是用到了正则表达式，使用的时候注意点


String对“+”的重载
	String str0 = "a";
	String str1 = str0 + "b";
	
	其中“+”反编译出来之后是这样的一个过程
	String str0 = "a";
	StringBuilder sb = new StringBuilder();
	sb.append(str0).append("b");
	String str1 = sb.toString();
	中间多出来了一个StringBuilder对象，这是一个临时对象。
	
	

String.valueOf和Integer.toString的区别
通过读String类的源码可以看到：
	public static String valueOf(int i) {
    	return Integer.toString(i);
	}
	String.valueOf(int i) 其实调用了Integer.toString(int i)方法
通过看Integer类的toString方法源码可以看到：
	public static String toString(int i) {
	    if (i == Integer.MIN_VALUE)
	        return "-2147483648";
	    int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);
	    char[] buf = new char[size];
	    getChars(i, size, buf);
	    return new String(buf, true);
	}
	除了当参数i=-2^31时，值返回"-2147483648"外，当i=其他值时，都返回一个新的Stirng对象（new String(buf,true)）

补充注意：
	java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常
	String.valueOf 这是一个静态方法，直接通过String调用，可以说是完美，只是平时不习惯这样写而已，这样的实现避免了前面两个的不足和缺点。
	源码如下：
		public static String valueOf(Object obj){
    		return (obj==null) ? "null" : obj.toString()
		};
	我们应当注意到，当object为null 时，String.valueOf（object）的值是字符串”null”，而不是null！！！在使用过程中切记要注意。

字符串的不可变性  
	通过查看String源码可知：
		/** The value is used for character storage. */
    	private final char value[];
    	String类是依赖一个私有字符常量表实现的；
    	例如：
    		String c1=new String("abc");
        	String c2=new String("abc");
        	String c3=c1;
        	System.out.println("c1==c2:"+  (c1==c2));
        	System.out.println("c1.equals(c2):"+c1.equals(c2));
        	System.out.println("c3==c1:"+(c3==c1));
        	System.out.println("c1.equals(c3):"+c1.equals(c3));
        	c1="han";
        	System.out.println(c1+"   "+c3);
        	System.out.println(""+(c3==c1));
        	
        	第一个输出语句c1==c2很好理解，因为c1和c2都是用new 创建的对象的引用，虽然对象的值相同，但两个对象在不同的内存空间，也就是说c1和c2是对两个不同的对象的引用，所以结果为false。
        	第二个输出语句c1.equals(c2)是调用了String类的equals方法，该方法用于比较两个字符串对象的值是否相等，所以结果为true。
        	对于c3==c1为true是因为将c1赋值给了c3 也就是将c1对象的引用赋值给了c3；
        	对于System.out.println(c1+"   "+c3)，这个输出语句有人会问既然c1和c3引用的是同一个对象，为什么改变c1的值c3的值并不会改变呢？
			
			这就涉及到了Java中String对象的不可变性，什么叫不可变性呢，简单的说就是一旦一个String对象被创建并被赋值（初始化）这个对象的值就不会变化。
			一旦一个String对象在内存中创建，它将是不可改变的，所有的String类中方法并不是改变String对象自己，而是重新创建一个新的String对象。
			也就是说c1=han，并不是改变了原有对象的值，而是创建了一个新的字符串对象，这个对象的值是han，并把这个对象的引用赋值给了c1。
        	所以c1==c3 为false
        	
        	正因为String对象的不可变性，如果需要对字符串进行大量的修改、添加字符、删除字符等操作尽量不要使用String对象，因为这样会频繁的创建新的对象导致程序的执行效率下降
			这时我们可以使用字符串生成器StringBuilder

String、StringBuffer、StringBuilder区别
	源码层面分析：
		 /** The value is used for character storage. */
    		private final char value[];
    	String类是依赖一个私有字符常量表实现的
    	String为字符串常量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的
    	 /**
    	 * The value is used for character storage.
    	 */
    	char[] value;
    	StringBuffer与StringBuilder都是继承AbstractStringBuilder，然而AbstractStringBuilder类是依赖一个字符变量表实现的
    	StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多
    	
    	在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的
    	如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。
    	所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。
    	
自动拆装箱:自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。
		因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱.
java为什么要引入自动装箱和拆箱的功能？
	主要是用于java集合中，List<Inteter> list=new ArrayList<Integer>();
	list集合如果要放整数的话，只能放对象，不能放基本类型，因此需要将整数自动装箱成对象,基本数据类型，
	如int,float,double,boolean,char,byte,不具备对象的特征，不能调用方法。
例子：
	装箱：将基本类型转换成包装类对象
	int i=10;
	Integer x=new Integer(i);手动装箱
	Integer y=10;自动装箱
	Integer的缓存机制  不知道
	
	拆箱：将包装类对象转换成基本类型的值
	Integer j=new Integer(8);
	int m=j.intValue();//手动拆箱
	int n=j;//自动拆箱
注意点(弊端):
	容易生成无用对象,因为自动装箱会隐式地创建对象，像前面提到的那样，如果在一个循环体中，会创建无用的中间对象，这样会增加GC压力，拉低程序的性能。
	所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作.

Integer的缓存机制
	Java 编译器把原始类型自动转换为封装类的过程称为自动装箱（autoboxing），这相当于调用 valueOf 方法
	 JDK 源码中对应实现的部分在哪里了。我们来看看 valueOf 的源码。下面是 JDK 1.8.0 build 25 中的代码
	 	public static Integer valueOf(int i) {
       		if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
           		return IntegerCache.cache[i + (-IntegerCache.low)];
       		
       		return new Integer(i);
   		}
   	在创建新的 Integer 对象之前会先在 IntegerCache.cache 中查找。有一个专门的 Java 类来负责 Integer 的缓存
   	这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。
   	最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。
   	缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。
   	这个缓存会在 Integer 类第一次被使用的时候被初始化出来。
   	以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。
   	
   	实际上在 Java 5 中引入这个特性的时候，范围是固定的 -128 至 +127。
   	后来在 Java 6 中，最大值映射到 java.lang.Integer.IntegerCache.high，可以使用 JVM 的启动参数设置最大值。
   	这使我们可以根据应用程序的实际情况灵活地调整来提高性能。是什么原因选择这个 -128 到 127 这个范围呢？因为这个范围的整数值是使用最广泛的。 
   	在程序中第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存
   	
   	这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。

	有 ByteCache 用于缓存 Byte 对象
	有 ShortCache 用于缓存 Short 对象
	有 LongCache 用于缓存 Long 对象
	有 CharacterCache 用于缓存 Character 对象
	Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。

熟悉Java中各种关键字   了解部分  大部分不清楚
	transient、instanceof、volatile、synchronized、final、static、const 原理及用法。

集合类
常用集合类的使用
ArrayList和LinkedList和Vector的区别: 
	Vector&ArrayList简介及特点
		1、Vector是内部是以动态数组的形式来存储数据的。
		2、Vector具有数组所具有的特性、通过索引支持随机访问、所以通过随机访问Vector中的元素效率非常高、但是执行插入、删除时效率比较地下、具体原因后面有分析。
		3、Vector实现了AbstractList抽象类、List接口、所以其更具有了AbstractList和List的功能、前面我们知道AbstractList内部已经实现了获取Iterator和ListIterator的方法、所以Vector只需关心对数组操作的方法的实现、
		4、Vector实现了RandomAccess接口、此接口只有声明、没有方法体、表示Vector支持随机访问。
		5、Vector实现了Cloneable接口、此接口只有声明、没有方法体、表示Vector支持克隆。
		6、Vector实现了Serializable接口、此接口只有声明、没有方法体、表示Vector支持序列化、即可以将Vector以流的形式通过ObjectOutputStream来写入到流中。
		7、Vector由于使用了synchronized方法-线程安全，所以性能上比ArrayList要差,所以Vector是线程安全的。
	LinkedList的特点：
		是一个双链表，在add和remove时比ArrayList性能好，但get和set时就特别慢了。
		双向链表，链表的一种。每个数据结点中都有两个指针，分别指向直接前驱和直接后继。因此，我们可以方便的访问他的前驱结点和后继结点。
		特点： 
		 1、 LinkedList以链表的形式存储数据、对增删元素有很高的效率、查询效率较低、尤其是随机访问、效率不忍直视、
       	 2、 LinkedList继承AbstractSequentialdList（其继承与AbstractList、所以要求其子类要实现通过索引操作元素）、使得LinkedList支持使用索引的“增删改查”操作、
         3、LinkedList直接实现了List接口、使其可以内部存储元素有序并且为每个元素提供索引值、
         4、LinkedList直接实现了Deque接口、Deque接口继承了Queue、使其可以作为双向链表这种数据结构来使用、操作元素、
         5、LinkedList直接实现了Cloneable接口、使其可以复制其中的全部元素
         6、在使用ObjectOutputStream/ObjectInputStream流时、会先讲LinkedList的capacity读取/写入到流中、然后将元素一一读取/写入。

SynchronizedList和Vector的区别   不知道

HashMap、HashTable、ConcurrentHashMap区别  了解并掌握hashmap

Java 8中stream相关用法  见过

apache集合处理工具类的使用   不知道

不同版本的JDK中HashMap的实现的区别以及原因   清楚jdk1.7和jdk1.8的区别和原因
1.8中应用了红黑树的数据结构   在链表节点超过8个的时候自动转换为红黑树结构  当红黑树的节点减少到6个时  自动转换为链表结构

枚举
枚举的用法、枚举与单例、Enum类 已整理

Java IO&Java NIO，并学会使用    

bio、nio和aio的区别、三种IO的用法与原理、netty

Java反射与javassist    不清楚
反射与工厂模式、 java.lang.reflect.*

Java序列化    没接触
什么是序列化与反序列化、为什么序列化
序列化底层原理
序列化与单例模式
protobuf
为什么说序列化并不安全

注解  没接触
元注解、自定义注解、Java中常用注解使用、注解与反射的结合

JMS 没接触
什么是Java消息服务、JMS消息传送模型

JMX  没见过
java.lang.management.*、 javax.management.*

泛型   表面了解
泛型与继承
类型擦除
泛型中K T V E  
object等的含义、泛型各种用法

单元测试  没玩儿过
junit、mock、mockito、内存数据库（h2）

正则表达式  知道  但不会用
java.lang.util.regex.*

常用的Java工具库  用过其中一个
commons.lang, commons.*... guava-libraries netty

什么是API&SPI  不知道

异常  了解  但不会用
异常类型、正确处理异常、自定义异常

时间处理  没用过
时区、时令、Java中时间API

编码方式  了解但不会用
解决乱码问题、常用编码方式

语法糖 不知道
Java中语法糖原理、解语法糖

Java并发编程  表面了解
什么是线程，与进程的区别

阅读源代码，并学会使用   没读过
Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors

线程池  没用过
自己设计线程池、submit() 和 execute()

线程安全  不清楚
死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系

锁 了解一部分
CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁

死锁  了解
volatile
happens-before、编译器指令重排和CPU指令重

synchronized  不是很明白
synchronized是如何实现的？
synchronized和lock之间关系
不使用synchronized如何实现一个线程安全的单例
sleep 和 wait
wait 和 notify
notify 和 notifyAll

ThreadLocal  不知道
写一个死锁的程序

写代码来解决生产者消费者问题  不会写只知道

守护线程  不知道
守护线程和非守护线程的区别以及用法  不知道