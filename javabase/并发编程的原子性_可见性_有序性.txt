解决缓存一致性问题，需了解并发编程中的三个概念：原子性，有序性，可见性。

1、原子性
	1）定义：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
	2）例子：
		一个很经典的例子就是银行账户转账问题：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。
		试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。
		所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。
	3）Java中的原子性：
		1)定义：对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
		2）例子：
			x = 10;         //语句1
			y = x;         //语句2
			x++;           //语句3
			x = x + 1;     //语句4
			语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
			语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
			同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。
			所以上面4个语句只有语句1的操作具备原子性。
			也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。
		3）Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。
		由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。
2、可见性：
	1）定义：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
	2）例子：
	//线程1执行的代码
	int i = 0;
	i = 10;
 
	//线程2执行的代码
	j = i;
	当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。
	此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.
	这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。
	3）Java中的可见性
		1）定义：对于可见性，Java提供了volatile关键字来保证可见性。
		当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
		而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
		另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
3、有序性
	1）定义：即程序执行的顺序按照代码的先后顺序执行。
	2）例子：
		int i = 0;             
 
		boolean flag = false;
 
		i = 1;                //语句1 
		flag = true; 
		定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。
		指令重排序：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
	 例子2：
	 	int a = 10;    //语句1
		int r = 2;    //语句2
		a = a + 3;    //语句3
		r = a*a;     //语句4
		执行性顺序可能是：语句2 语句1 语句3 语句4
		不可能有这个执行顺序：语句2 语句1 语句4 语句3
		因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。
	例子3：
		//线程1:
 
		context = loadContext();   //语句1
		inited = true;             //语句2
 
 		//线程2:
		while(!inited ){
		   sleep()
		}
		doSomethingwithconfig(context);
		
		上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。
		从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
		也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
	3）Java中的有序性
		1）定义：在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
				在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
				
